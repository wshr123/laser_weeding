def detect_green_circles(self, image):
    import cv2
    import numpy as np

    # 转为灰度图
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image.copy()

    # ---------- 霍夫圆检测 ----------
    blurred = cv2.GaussianBlur(gray, (9, 9), 2)
    
    circles = cv2.HoughCircles(
        blurred,
        cv2.HOUGH_GRADIENT,
        dp=1,
        minDist=30,
        param1=50,
        param2=30,
        minRadius=5,
        maxRadius=0
    )
    
    # 当前帧检测到的圆
    current_circles = []
    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        for (x, y, r) in circles:
            current_circles.append({
                'center': (x, y),
                'radius': r,
                'area': np.pi * r * r
            })

    # ---------- 初始化跟踪变量（保持在self中） ----------
    if not hasattr(self, '_tracked_circles'):
        self._tracked_circles = []
    if not hasattr(self, '_next_circle_id'):
        self._next_circle_id = 0
    if not hasattr(self, '_frame_count'):
        self._frame_count = 0
    
    self._frame_count += 1

    # ---------- 跟踪逻辑 ----------
    max_distance = 50  # 最大跟踪距离
    max_missing_frames = 5  # 最大丢失帧数
    
    # 为当前检测到的圆分配ID
    updated_tracks = []
    used_detections = set()
    
    # 1. 更新现有轨迹
    for track in self._tracked_circles:
        best_match = None
        best_distance = max_distance
        best_idx = -1
        
        # 寻找最近的检测结果
        for i, detection in enumerate(current_circles):
            if i in used_detections:
                continue
                
            distance = np.hypot(
                track['center'][0] - detection['center'][0],
                track['center'][1] - detection['center'][1]
            )
            
            # 同时考虑位置和半径的相似性
            radius_diff = abs(track['radius'] - detection['radius'])
            if distance < best_distance and radius_diff < track['radius'] * 0.5:
                best_match = detection
                best_distance = distance
                best_idx = i
        
        if best_match is not None:
            # 找到匹配，更新轨迹
            used_detections.add(best_idx)
            
            # 平滑滤波更新位置和半径
            alpha = 0.7  # 历史权重
            new_x = int(alpha * track['center'][0] + (1-alpha) * best_match['center'][0])
            new_y = int(alpha * track['center'][1] + (1-alpha) * best_match['center'][1])
            new_r = int(alpha * track['radius'] + (1-alpha) * best_match['radius'])
            
            updated_tracks.append({
                'id': track['id'],
                'center': (new_x, new_y),
                'radius': new_r,
                'area': np.pi * new_r * new_r,
                'missing_frames': 0,
                'confidence': min(1.0, track['confidence'] + 0.2)
            })
        else:
            # 没找到匹配，增加丢失帧数
            track['missing_frames'] += 1
            if track['missing_frames'] < max_missing_frames:
                # 保持原位置，降低置信度
                track['confidence'] = max(0.1, track['confidence'] - 0.3)
                updated_tracks.append(track)
    
    # 2. 为未匹配的检测创建新轨迹
    for i, detection in enumerate(current_circles):
        if i not in used_detections:
            updated_tracks.append({
                'id': self._next_circle_id,
                'center': detection['center'],
                'radius': detection['radius'],
                'area': detection['area'],
                'missing_frames': 0,
                'confidence': 0.5  # 新轨迹初始置信度较低
            })
            self._next_circle_id += 1
    
    # 3. 过滤低置信度和长时间丢失的轨迹
    self._tracked_circles = [
        track for track in updated_tracks 
        if track['confidence'] > 0.1 and track['missing_frames'] < max_missing_frames
    ]
    
    # ---------- 输出稳定的检测结果（保持原有格式） ----------
    # 只输出高置信度的轨迹，格式与原函数保持一致
    stable_circles = []
    for track in self._tracked_circles:
        if track['confidence'] > 0.4:  # 只输出置信度较高的
            stable_circles.append({
                'id': track['id'],  # 保持ID用于跟踪
                'center': track['center'],
                'radius': track['radius'],
                'area': track['area']
            })
    
    # 按面积排序
    stable_circles.sort(key=lambda x: x['area'], reverse=True)
    
    # 保持原有的输出变量名
    self.detected_circles = stable_circles[:10]  # 最多返回10个
    
    # 如果需要兼容原有代码，可以去掉ID字段
    # self.detected_circles = [
    #     {'center': c['center'], 'radius': c['radius'], 'area': c['area']}
    #     for c in stable_circles[:10]
    # ]
